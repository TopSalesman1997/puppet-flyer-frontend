<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0, user-scalable=yes"/>
<title>Puppet Flyer</title>

<!-- Pixelated font (Press Start 2P) -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:monospace;
    background:linear-gradient(#64b5f6,#1976d2);
    padding:10px 20px 20px; /* shrink vertical padding to reduce blue height */
  }

  /* Top bar wrapper sits on blue background */
.top-bar-wrapper {
  max-width: 1200px;
  margin: 0 auto 8px auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  z-index: 99999;
  pointer-events: auto;
}

 .logo-and-title{
  display: flex;
  flex-direction: row; 
  align-items: flex-start;
  justify-content: flex-start;
  gap: 10px;
}

  .logo-and-title img{
    height:48px;
  }

  .logo-and-title .title-text{
    font-family:"Press Start 2P", monospace;
    font-size:20px;
    color:#ffff;
    letter-spacing:0.04em;
  }

.back-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  align-self: flex-start;
  position: relative;
  z-index: 100000;
  pointer-events: auto;

  font-family: "Press Start 2P", monospace;
  font-size: 9px;
  line-height: 1.2;
  text-align: center;

  color: #fff;
  text-decoration: none;

  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.35);
  border: 2px solid rgba(255, 255, 255, 0.55);
  border-radius: 4px;

  transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
  white-space: nowrap;
}

.back-button-top {
  opacity: 0.85;
  font-size: 8px;
}

.back-button-bottom {
  font-size: 9px;
  margin-top: 2px;
}

.back-button:hover {
  background: rgba(0, 0, 0, 0.55);
  border-color: #ffffff;
  transform: translateX(-2px);
}

.back-button:active {
  transform: translateX(-1px);
}

/* ‚úÖ ADD THIS: Makes button version behave like link version */
button.back-button {
  cursor: pointer;
  border: 2px solid rgba(255, 255, 255, 0.55); /* Ensures button has same border */
}

  /* White game area (title + canvas + leaderboards) */
  .game-container{
    background:#fff;
    padding:30px;
    border-radius:10px;
    box-shadow:0 10px 40px rgba(0,0,0,.3);
    max-width:1000px;
    width:100%;
    margin:0 auto;
    position:relative;
  }

  /* Big centered title inside white game area */
  .game-title{
    font-family:"Press Start 2P", monospace;
    text-align:center;
    font-size:32px;
    letter-spacing:0.08em;
    margin-bottom:20px;
    color:#333;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:16px;
  }

  /* Make title logos equally spaced from text */
  .game-title .title-logo:first-of-type{
    margin-right:16px;
  }
  .game-title .title-logo:last-of-type{
    margin-left:16px;
  }

  .game-title .title-logo{
    height:48px;
  }

  #gameCanvas{border:4px solid #333;border-radius:5px;display:block;margin:0 auto;image-rendering:pixelated;max-width:100%;height:auto;touch-action:manipulation;cursor:pointer; background: #000; }

  .controls{text-align:center;margin-top:20px}

  /* small utility */
  .small { font-size:12px; color:#555; margin-top:8px; }

  /* Countdown overlay (minimal, non-invasive) */
  .countdown-overlay {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 40;
  }
  .countdown-number {
    font-family: 'Press Start 2P', monospace;
    color: #0CAF0C; /* green matching strings */
    font-size: 77px; /* reduced (approx 80% of original) */
    line-height: 1;
    text-shadow: 0 0 8px rgba(12,175,12,0.35);
    opacity: 0;
    transition: transform 0.28s ease, opacity 0.28s ease;
    transform: translateY(6px) scale(0.98);
    pointer-events: none;
  }
  .countdown-number.show {
    opacity: 1;
    transform: translateY(0) scale(1.02);
  }

  /* UI overlay placed over the canvas (start/game-over/play-again) */
  .ui-overlay {
    position: absolute;
    z-index: 45;
    pointer-events: none; /* enabled selectively for buttons */
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    text-align: center;
  }
  .ui-overlay .pixel-btn {
    font-family: 'Press Start 2P', monospace;
    color: #0CAF0C;
    background: rgba(0,0,0,0.6);
    border: 2px solid rgba(12,175,12,0.35);
    padding: 10px 18px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    pointer-events: auto;
    margin-top: 12px;
  }
  .ui-overlay .pixel-btn:active { transform: translateY(1px); }
  .ui-overlay .pixel-btn:focus { outline: 2px solid rgba(12,175,12,0.5); }

  .ui-overlay .game-over {
    font-family: 'Press Start 2P', monospace;
    color: #0CAF0C;
    font-size: 48px; /* GAME OVER size (reduced) */
    text-shadow: 0 0 8px rgba(12,175,12,0.25);
    margin-bottom: 6px;
    pointer-events: none;
  }
  .ui-overlay .high-score {
    font-family: 'Press Start 2P', monospace;
    color: #0CAF0C;
    font-size: 22px; /* score size (reduced) */
    margin-bottom: 8px;
    pointer-events: none;
  }

  /* Instruction text outside the game (minimal) */
  .instructions {
    margin-top: 12px;
    font-weight: 700;
    color: #333;
    display: inline-block;
    background: rgba(255,255,255,0.9);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    letter-spacing: 0.6px;
  }

  /* Welcome heading (make slightly brighter for visibility) */
  .welcome-heading {
    color: #111; /* darker/clearer */
    text-shadow: 0 1px 0 rgba(255,255,255,0.08);
  }

/* Responsive (minimal) */
@media (max-width:680px) {
.logo-and-title {
    width: 100%; /* Take up full width to allow alignment */
    display: flex;
    justify-content: flex-start; /* Push children (the button) to the left */
  }

  .back-button {
    margin-left: 5px;
    margin-top: 5px;
  }
  .game-container { padding:18px; }
  .countdown-number { font-size: 52px; }
  .ui-overlay .game-over { font-size: 36px; }
  .ui-overlay .high-score { font-size: 18px; }
  .ui-overlay .pixel-btn { font-size: 12px; padding:8px 12px; }

  /* Stack auth under title on small screens */
  .top-bar-wrapper {
    flex-direction: column;
    align-items: center;
    gap:10px;
  }

  /* Ensure auth panel fits phone width without forcing vertical stacking */
  #auth-panel {
    width: 95%;
    max-width: 420px;
    min-width: auto; 
    padding: 8px 10px;
  }

 /* Keep rows flexible on small screens */
#auth-panel .auth-row {
  display: flex;
  flex-wrap: wrap;        /* allow wrap if there isn't enough horizontal space */
  gap: 8px;
  align-items: center;
  margin-bottom: 8px;
}

#auth-panel .auth-row input[type="text"],
#auth-panel .auth-row input[type="password"] {
  flex: 1 1 120px;       /* prefers 120px, but can shrink or wrap */
  width: 0;              /* flexbox width calculation */
  min-width: 0;          /* critical: allow smaller than intrinsic size */
}

#auth-panel .auth-row button {
  flex: 0 0 110px;       /* slightly narrower button to help fit */
  text-align: center;
  padding: 6px 0;
}
}

  /* Leaderboard button active state */
  .leaderboard-btn.active {
    background-color: #1976d2 !important;
    color: white !important;
  }
  /* Leaderboard list items */
  #leaderboard-list li {
    padding: 6px 8px;
    border-bottom: 1px solid #ddd;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
  }

  /* Side-by-side leaderboards container */
  .leaderboards-container {
    display: flex;
    gap: 20px;
    margin-top: 20px;
    justify-content: center;
    align-items: flex-start;
  }

  .leaderboard-section, .stats-section {
    flex: 1;
    max-width: 450px;
    background: #f9f9f9;
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    font-family: monospace;
  }

  /* Player Stats list items */
  #user-stats-list li {
    padding: 6px 8px;
    border-bottom: 1px solid #ddd;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  @media (max-width: 900px) {
    .leaderboards-container {
      flex-direction: column;
      align-items: center;
    }
    .leaderboard-section, .stats-section {
      max-width: 400px;
      width: 100%;
    }
  }

 /* ==== Horizontal, slimmer auth panel on blue ==== */
#auth-panel {
  width: 100%;
  max-width: 420px;          /* cap width on larger screens */
  /* remove min-width:380px; */
  padding:8px 14px;
  background:#ffff;
  border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,0.18);
  display:flex;
  flex-direction:column;
  gap:6px;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 13px;
}

  /* Each row: input field + button side by side */
  .auth-row {
    display:flex;
    flex-direction:row;
    align-items:center;
    gap:10px;
  }

  .auth-row input[type="text"],
  .auth-row input[type="password"]{
    flex:1;
    box-sizing:border-box;
    padding:6px 8px;
    border-radius:4px;
    border:1px solid #ccc;
    font-size:12px;
  }

  .auth-row button{
    min-width:110px;
    padding:6px 10px;
    font-size:12px;
    border-radius:4px;
    cursor:pointer;
    font-weight:600;
  }

  #auth-signin-btn{
    background-color:#0d6efd;
    color:#fff;
    border:1px solid #0d6efd;
  }

  #auth-signup-btn{
    background-color:#f8f9fa;
    color:#0d6efd;
    border:1px solid #0d6efd;
  }

  /* ==== Signup modal styles ==== */
  .signup-modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  .signup-modal.open {
    display: flex;
  }

  .signup-dialog {
    background: #fff;
    border-radius: 8px;
    padding: 16px 18px;
    width: 320px;
    max-width: 90%;
    box-shadow: 0 8px 28px rgba(0,0,0,0.35);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    font-size: 14px;
  }

  .signup-dialog h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 18px;
    text-align: center;
    color: #1976d2;
  }

  .signup-dialog label {
    display: block;
    margin-bottom: 8px;
  }

  .signup-dialog input {
    width: 100%;
    box-sizing: border-box;
    padding: 4px 6px;
    margin-top: 2px;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 13px;
  }

  .signup-actions {
    margin-top: 10px;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }

  .signup-actions button {
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #1976d2;
    background: white;
    color: #1976d2;
    font-weight: 600;
    font-size: 13px;
  }

  .signup-error {
    color: #c00;
    font-size: 12px;
    margin-top: 4px;
    min-height: 16px;
  }

  /* Forgot password link */
  .forgot-password-link {
    font-size: 11px;
    color: #0d6efd;
    text-decoration: underline;
    cursor: pointer;
    margin-top: 4px;
    display: inline-block;
  }
  .forgot-password-link:hover {
    color: #0a58ca;
  }

  /* ===== Verification overlay styles ===== */
  .verify-overlay {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 99999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(3px);
    padding: 16px;
    box-sizing: border-box;
  }

  .verify-overlay.hidden {
    display: none;
  }

  .verify-box {
    max-width: 520px;
    width: 100%;
    margin: 0 auto;
    padding: 22px;
    background: #ffffff;
    color: #111;
    border-radius: 8px;
    box-shadow: 0 6px 24px rgba(0,0,0,0.3);
    text-align: center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  }

  .verify-box h2 {
    margin: 0 0 8px;
    font-size: 20px;
  }

  .verify-box p {
    margin: 0 0 12px;
    color: #333;
    font-size: 14px;
  }

  .verify-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 12px;
    align-items: center;
  }

  .verify-btn {
    padding: 8px 12px;
    cursor: pointer;
    border: 1px solid #ccc;
    background: #f7f7f7;
    border-radius: 4px;
    font-size: 14px;
  }

  .verify-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .verify-signout {
    margin-left: 6px;
    color: #c00;
    text-decoration: underline;
    cursor: pointer;
    font-size: 14px;
  }

  .verify-status {
    margin-top: 12px;
    color: #444;
    font-size: 13px;
    min-height: 18px;
  }

/* Fullscreen toggle button - Merged & Fixed */
#fullscreen-toggle {
  position: absolute;
  top: 10px;
  right: 10px;
  
  /* Critical Fixes */
  z-index: 10000 !important; /* Must be higher than .top-bar-wrapper (200) */
  pointer-events: auto !important;
  
  padding: 6px 10px;
  font-size: 11px;
  line-height: 1.2;
  border-radius: 4px;
  border: none;
  background: rgba(0,0,0,0.6);
  color: #fff;
  cursor: pointer;
  text-align: center;
}

/* Landscape-specific tweak for the button */
@media (max-width: 900px) and (orientation: landscape) {
  body.fullscreen-game #fullscreen-toggle {
    right: 20px; /* Move it slightly in from the edge for notched phones */
    top: 15px;
  }
}

/* Rotate hint overlay inside the game canvas area */
.rotate-canvas-overlay {
  position: absolute;
  top: 74%;               /* lower than center to cover START GAME */
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 500;

  padding: 8px 3px;     /* vertical, horizontal */
min-width: 240px;
  max-width: 280px;       /* narrower box */
  border-radius: 4px;
  background: rgba(10, 10, 10, 0.95);
  border: 2px solid #3cff7a;      /* slightly thinner border */
  box-shadow: 0 0 0 2px #1c221f, 0 0 10px rgba(0, 0, 0, 0.8);

  font-family: "Courier New", monospace;
  text-align: center;
  color: #e6e6e6;
  font-size: 10px;         /* smaller text */
  letter-spacing: 0.4px;
  line-height: 1.35;
  display: none;
  pointer-events: none;
}

/* Mobile / tablet fullscreen behaviour */
@media (max-width: 900px) {
  body.fullscreen-game {
    overflow: hidden;
    background: #000;
  }

  /* Hide non-game UI while in fullscreen */
  body.fullscreen-game #auth-panel,
  body.fullscreen-game .leaderboards-container,
  body.fullscreen-game .instructions {
    display: none;
  }
}

/* Portrait tweaks while in fullscreen, any width constraint you like */
@media (max-width: 900px) and (orientation: portrait) {
  body.fullscreen-game .game-container {
    padding: 8px;
  }
}

/* Landscape fullscreen layout */
@media (max-width: 900px) and (orientation: landscape) {
  body.fullscreen-game .game-container {
    position: absolute !important;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
    
    /* ‚úÖ ADD THIS: Pushes the game right to make room for the side buttons */
    padding-left: 100px; 
  }

  body.fullscreen-game {
    position: fixed;
    width: 100%;
    height: 100%;
  }

  /* ‚úÖ NEW BLOCK: Moves the Back/Rules buttons to a left-side rail */
  body.fullscreen-game .top-bar-wrapper {
    position: fixed;
    top: 0;
    left: 0;
    width: 100px; /* Width of your side rail */
    height: 100%;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    padding: 15px 5px;
    gap: 12px;
    background: rgba(0, 0, 0, 0.7); /* Darker background for contrast */
    z-index: 200; /* Above the game container */
    pointer-events: auto;
  }

  body.fullscreen-game .logo-and-title {
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  body.fullscreen-game .back-button {
    font-size: 7px; /* Smaller text to fit vertically */
    padding: 6px 4px;
    width: 90px;
    white-space: normal; /* Allows text to wrap if needed */
  }

  body.fullscreen-game .game-title {
    display: none !important;
  }

  body.fullscreen-game #gameCanvas {
    max-height: calc(100vh - 20px);
    max-height: calc(100dvh - 20px);
    max-width: calc(100vw - 110px); /* Adjusted to account for the side rail */
    height: auto;
    width: auto;
    box-shadow: 0 0 0 4px #3c352b;
  }
}

/* ‚úÖ ADD THIS: Fixes the Exit Fullscreen button click issue */
#fullscreen-toggle {
  pointer-events: auto !important;
  z-index: 1000 !important;
}

/* ========== RULES MODAL (Rotate-device style) ========== */

/* NOTE: You are using the top-bar .back-button for the rules trigger,
   so .rules-btn is likely unused. Keep it only if you still use it somewhere. */
.rules-btn {
  margin-left: 10px;
  font-size: 14px;
  padding: 8px 16px;
  background: #111;
  color: #00ff66;
  border: 2px solid #00ff66;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
  text-transform: uppercase;
  box-shadow: 0 0 0 2px rgba(0,255,102,0.15);
  transition: transform 0.1s ease, background 0.1s ease;
}

.rules-btn:hover { background: #151515; transform: translateY(-1px); }
.rules-btn:active { transform: translateY(0px); }

/* Fullscreen overlay (matches rotate device overlay behavior) */
.modal-overlay {
  position: fixed;
  inset: 0; /* replaces top/left/width/height */
  background: rgba(0, 0, 0, 0.85);
  z-index: 100000;           /* above game/canvas/top bar */
  display: flex;             
  align-items: center;
  justify-content: center;
  padding: 16px;
  pointer-events: auto;
}

/* Panel (black with green border like rotate prompt) */
.modal-panel {
  background: #0b0b0b;
  border: 2px solid #00ff66;
  box-shadow: 0 0 0 2px rgba(0,255,102,0.12), 0 12px 40px rgba(0,0,0,0.6);
  max-width: 620px;
  width: min(620px, 92vw);
  max-height: 85vh;
  position: relative;
  padding: 18px 16px 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  color: #e9ffe9;

  /* Pixel font for headings is fine, but it‚Äôs hard to read for long rules.
     We'll apply Press Start to title only, and keep body readable below. */
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  text-shadow: none;
  border-radius: 8px;
}

/* Close button (simple, like rotate overlay UI) */
.modal-close {
  position: absolute;
  top: 10px;
  right: 10px;

  background: transparent;
  color: #00ff66;
  border: 1px solid rgba(0,255,102,0.6);
  width: 34px;
  height: 34px;
  border-radius: 6px;

  font-size: 18px;
  line-height: 1;
  cursor: pointer;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
}

.modal-close:hover {
  background: rgba(0, 255, 102, 0.10);
}

/* Title in pixel font (rotate overlay vibe) */
.rules-title {
  font-family: 'Press Start 2P', monospace;
  font-size: 14px;
  text-align: center;
  margin: 6px 0 14px 0;
  line-height: 1.5;
  color: #00ff66;
}

/* Body content readable */
.rules-content {
  font-size: 14px;
  line-height: 1.55;
  color: #e9ffe9;
}

/* Sections */
.rules-section {
  margin-bottom: 14px;
  padding: 12px;
  background: rgba(0, 255, 102, 0.06);
  border: 1px solid rgba(0, 255, 102, 0.35);
  border-radius: 8px;
}

.rules-section h3 {
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
  margin: 0 0 10px 0;
  color: #00ff66;
}

.rules-section ol,
.rules-section ul {
  margin: 8px 0;
  padding-left: 20px;
}

.rules-section li {
  margin-bottom: 10px;
}

/* Notes */
.rules-note {
  display: block;
  font-size: 12px;
  color: rgba(233, 255, 233, 0.75);
  margin-top: 6px;
  font-style: italic;
}

/* Prize list */
.prize-list {
  list-style: none;
  padding: 0;
  margin: 12px 0 0;
}

.prize-list li {
  display: flex;
  justify-content: space-between;
  padding: 10px 10px;
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(0, 255, 102, 0.35);
  border-radius: 8px;
  margin-bottom: 8px;
}

.prize-rank {
  color: #00ff66;
  font-weight: 700;
}

.prize-amount {
  color: #00ff66;
  font-weight: 700;
}

/* Callouts */
.bigshot-callout {
  font-size: 13px;
  color: #e9ffe9;
  margin: 12px 0;
}

.bigshot-cta {
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
  text-align: center;
  color: #00ff66;
  margin-top: 14px;
}

/* Keep highlight but make it match the green theme */
.highlight {
  color: #00ff66;
  text-shadow: 0 0 10px rgba(0,255,102,0.35);
}

/* Mobile adjustments */
@media (max-width: 680px) {
  .modal-panel {
    width: min(560px, 94vw);
    max-height: 86vh;
    padding: 16px 12px 12px;
  }

  .rules-title { font-size: 12px; }
  .rules-content { font-size: 13px; }
  .rules-section h3 { font-size: 11px; }
  .bigshot-cta { font-size: 11px; }
}

/* ========== UTILITY CLASSES ========== */
.hidden {
  display: none !important;
}
</style>
</head>
<body>

  <!-- Top bar on blue background -->
  <div class="top-bar-wrapper">
    <!-- Left side now empty (banner can be shorter); kept for layout balance -->
<div class="logo-and-title">
  <!-- Back Button -->
  <a href="https://bigshot.today" class="back-button" aria-label="Back to bigshot.today">
    <span class="back-button-top">BACK TO</span>
    <span class="back-button-bottom">BIGSHOT.TODAY</span>
  </a>

  <!-- Rules Button (Styled exactly like the back button) -->
  <button id="rules-button" class="back-button" type="button">
    <span class="back-button-top">VIEW</span>
    <span class="back-button-bottom">TOURNAMENT RULES</span>
  </button>
</div>

    <div id="auth-panel">
      <!-- Signed-out view: two rows, each with input + button -->
      <div id="auth-signed-out">
        <!-- Row 1: Email + Create Account -->
        <div class="auth-row">
          <input type="text" id="auth-email" placeholder="Email or Username" autocomplete="email" required>
          <button id="auth-signup-btn" type="button">Create Account</button>
        </div>
        <!-- Row 2: Password + Sign In -->
        <div class="auth-row">
          <input type="password" id="auth-password" placeholder="Password" autocomplete="current-password" required>
          <button id="auth-signin-btn" type="button">Sign In</button>
        </div>
        <div id="auth-error" style="color:#c00; margin-top:2px; font-size:0.8rem;"></div>
        <a id="auth-forgot-password" class="forgot-password-link">Forgot password?</a>
      </div>

      <!-- Signed-in view -->
      <div id="auth-signed-in" style="display:none; margin-top:0;">
        <div>Signed in as <span id="auth-username"></span></div>
        <button id="auth-signout-btn" type="button" style="margin-top:6px;">Sign Out</button>
      </div>
    </div>
  </div>

  <!-- White game area -->
<div class="game-container" style="position:relative;">
  <h1 class="game-title">
    <img src="assets/spamton.png" alt="Puppet Flyer logo left" class="title-logo">
    <span>Puppet Flyer</span>
    <img src="assets/spamton.png" alt="Puppet Flyer logo right" class="title-logo">
  </h1>

<!-- Fullscreen toggle button (top-right) -->
<button id="fullscreen-toggle" aria-label="Toggle fullscreen">
  Fullscreen<br><span style="font-size: 9px; opacity: 0.8;">(mobile)</span>
</button>

  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <!-- Countdown overlay (minimal, sits above canvas) -->
  <div class="countdown-overlay" id="countdownOverlay" aria-hidden="true">
    <div id="countdownNumber" class="countdown-number" role="status" aria-live="polite">3</div>
  </div>

 <!-- UI overlay that will contain Start / Game Over / Play Again inside the black game window -->
  <div id="uiOverlay" class="ui-overlay" aria-hidden="true"></div>

  <!-- Rotate hint overlay rendered inside the game area -->
  <div id="rotateCanvasOverlay" class="rotate-canvas-overlay" aria-hidden="true"></div>

  <!-- Instruction text outside the game environment -->
  <div style="text-align:center;">
    <div class="instructions">TO MOVE: Spacebar (Desktop) / Tap (Mobile)</div>
  </div>

  <!-- Side-by-side Leaderboards Container -->
  <div class="leaderboards-container">
    <!-- Global Leaderboard Section -->
    <div id="leaderboard-section" class="leaderboard-section" aria-label="Game Leaderboards" role="region">
      <h2 style="text-align: center; margin-bottom: 12px; color: #1976d2;">Global Leaderboards</h2>
      <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;">
        <button id="btn-weekly" class="leaderboard-btn" onclick="loadLeaderboard('weekly')" style="margin-right: 8px; padding: 6px 12px; cursor: pointer; border: 1px solid #1976d2; background: white; color: #1976d2; border-radius: 4px; font-weight: 700; user-select: none;">Weekly</button>
        <button id="btn-monthly" class="leaderboard-btn" onclick="loadLeaderboard('monthly')" style="margin-right: 8px; padding: 6px 12px; cursor: pointer; border: 1px solid #1976d2; background: white; color: #1976d2; border-radius: 4px; font-weight: 700; user-select: none;">Monthly</button>
        <button id="btn-alltime" class="leaderboard-btn" onclick="loadLeaderboard('alltime')" style="padding: 6px 12px; cursor: pointer; border: 1px solid #1976d2; background: white; color: #1976d2; border-radius: 4px; font-weight: 700; user-select: none;">All-Time</button>
      </div>
      <ul id="leaderboard-list" aria-live="polite" aria-relevant="additions" style="list-style: none; padding-left: 0; margin-top: 10px; max-height: 340px; overflow-y: visible;">
      </ul>
    </div>

    <!-- Player Stats Section -->
    <div id="player-stats-section" class="stats-section" aria-label="Player Statistics" role="region">
      <h2 id="user-stats-title" style="text-align: center; margin-bottom: 12px; color: #1976d2;">Player Stats</h2>
      <div id="user-stats-status" style="text-align: center; color: #888; font-size: 13px; margin-bottom: 8px;">Sign in to see your stats.</div>
      <ul id="user-stats-list" style="list-style: none; padding-left: 0; margin-top: 10px; max-height: 340px; overflow-y: visible;">
      </ul>
      <div id="user-total-score" style="text-align: center; margin-top: 12px; font-weight: bold; color: #1976d2; font-size: 14px;">Total Score: 0</div>
    </div>
  </div>
</div> <!-- end .game-container -->

  <!-- ==== Signup Modal ==== -->
  <div id="signup-modal" class="signup-modal" aria-hidden="true">
    <div class="signup-dialog">
      <h2>Create Account</h2>

      <label>
        Email
        <input type="email" id="signup-email" autocomplete="email" required>
      </label>

      <label>
        Password
        <input type="password" id="signup-password" autocomplete="new-password" required>
      </label>

      <label>
        Confirm Password
        <input type="password" id="signup-password-confirm" autocomplete="new-password" required>
      </label>

      <label>
        Username (no spaces or special characters)
        <input type="text" id="signup-username" maxlength="20" required>
      </label>

      <div id="signup-error" class="signup-error"></div>

      <div class="signup-actions">
        <button id="signup-submit-btn" type="button">Create</button>
        <button id="signup-cancel-btn" type="button">Cancel</button>
      </div>
    </div>
  </div>

<!-- Minimal fix for PHYSICS_SHRINK ReferenceError -->
<script>
  window.PHYSICS_SHRINK = (typeof window.PHYSICS_SHRINK === 'number' && Number.isFinite(window.PHYSICS_SHRINK)) ? window.PHYSICS_SHRINK : 0.84;
</script>

<!-- ===== Verification overlay ===== -->
<div id="verify-required-overlay" class="verify-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="verify-title" aria-describedby="verify-desc">
  <div class="verify-box" role="document">
    <h2 id="verify-title">Email verification required</h2>
    <p id="verify-desc">Please verify your email address to unlock gameplay and account features. Check your inbox (and spam folder).</p>

    <div class="verify-controls">
      <button id="verify-resend-btn" class="verify-btn" type="button">Resend verification email</button>
      <button id="verify-check-btn" class="verify-btn" type="button">I've verified ‚Äî check now</button>
      <a id="verify-signout" class="verify-signout" href="#">Sign out</a>
    </div>

    <div id="verify-status" class="verify-status" aria-live="polite"></div>
  </div>
</div>

<script>
  (function(){
    window.verifyOverlayEl = document.getElementById('verify-required-overlay');
    window.resendVerificationBtn = document.getElementById('verify-resend-btn');
    window.verifyCheckBtn = document.getElementById('verify-check-btn');
    window.verifySignoutLink = document.getElementById('verify-signout');
    window.verifyStatusEl = document.getElementById('verify-status');

    window.showVerificationOverlay = function() {
      try {
        if (window.verifyOverlayEl) window.verifyOverlayEl.classList.remove('hidden');
        try { window.resendVerificationBtn?.focus(); } catch(e) {}
      } catch(e) {
        console.warn('showVerificationOverlay error', e);
      }
    };

    window.hideVerificationOverlay = function() {
      try {
        if (window.verifyOverlayEl) window.verifyOverlayEl.classList.add('hidden');
        try {
          const restore = document.getElementById('auth-signin-btn') || document.getElementById('auth-signup-btn') || document.body;
          restore?.focus?.();
        } catch(e) {}
      } catch(e) {
        console.warn('hideVerificationOverlay error', e);
      }
    };
  })();
</script>

<!-- Rules Modal -->
<div id="rules-modal" class="modal-overlay hidden">
  <div class="modal-panel rules-panel">
    <button id="close-rules" class="modal-close">‚úï</button>
    <h2 class="rules-title">üéÆ PUPPET FLYER TOURNAMENT üéÆ</h2>
    
    <div class="rules-content">
      <section class="rules-section">
        <h3>üìã ELIGIBILITY</h3>
        <ol>
          <li><strong>Create an account & verify your email address</strong> to participate<br>
          <span class="rules-note">Only verified logged-in user scores are saved and eligible for prize winnings</span></li>
          <li><strong>Sign-in and play as many rounds as you want</strong><br>
          <span class="rules-note">Your scores will be automatically logged in the database, and the top ten scores will be displayed on our leaderboards, updated in real-time</span></li>
        </ol>
      </section>

      <section class="rules-section prize-section">
        <h3>üí∞ WEEKLY PRIZEPOOL - $100</h3>
        <p>Every week, <strong>$100 in prizes</strong> is paid out across the top 3 scores on the weekly leaderboard:</p>
        <ul class="prize-list">
          <li><span class="prize-rank">1st:</span> <span class="prize-amount">$60</span></li>
          <li><span class="prize-rank">2nd:</span> <span class="prize-amount">$25</span></li>
          <li><span class="prize-rank">3rd:</span> <span class="prize-amount">$15</span></li>
        </ul>
        <p class="rules-note">*Scores will be timestamped every Sunday @ 11:59pm EST<br>
        Any score recorded after that time will be considered for the following week's payout</p>
      </section>

      <section class="rules-section prize-section">
        <h3>üèÜ MONTHLY PRIZEPOOL - $400</h3>
        <p>Every month, an additional <strong>$400 in prizes</strong> will be paid across the top 5 scores on the monthly leaderboard:</p>
        <ul class="prize-list">
          <li><span class="prize-rank">1st:</span> <span class="prize-amount">$169</span></li>
          <li><span class="prize-rank">2nd:</span> <span class="prize-amount">$99</span></li>
          <li><span class="prize-rank">3rd:</span> <span class="prize-amount">$69</span></li>
          <li><span class="prize-rank">4th:</span> <span class="prize-amount">$42</span></li>
          <li><span class="prize-rank">5th:</span> <span class="prize-amount">$21</span></li>
        </ul>
        <p class="rules-note">*Scores will be timestamped on the final day of the month @ 11:59pm EST</p>
      </section>

      <section class="rules-section payout-section">
        <h3>üí∏ PAYOUTS</h3>
        <p style="margin-bottom: 1.5em;">All prizes will be paid in <strong>$Spamton tokens</strong> equal to the USD value of each respective prize level</p>
        <p>Winners will be contacted via their registered email address to arrange prize distribution</p>
        <p class="bigshot-callout"><strong>$800 in prizes given away EVERY MONTH to the community‚Ä¶so practice up!</strong></p>
        <p class="bigshot-cta">DON'T YOU WANNA BE A <span class="highlight">BIG SHOT</span>?!</p>
      </section>
    </div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
const DEBUG = false; // set true while debugging

/* ==== Asset loading (robust) ==== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const controlsDiv = document.getElementById('controls');
if (DEBUG) console.log('controlsDiv:', controlsDiv);
const uiOverlay = document.getElementById('uiOverlay');
const countdownOverlay = document.getElementById('countdownOverlay');

// Mobile fullscreen toggle
const fullscreenBtn = document.getElementById('fullscreen-toggle');
const rotateCanvasOverlay = document.getElementById('rotateCanvasOverlay');

function isMobilePortrait() {
  return window.innerWidth <= 768 && window.innerHeight > window.innerWidth;
}

function updateRotateOverlay() {
  const inFullscreen = document.body.classList.contains('fullscreen-game');
  if (inFullscreen && isMobilePortrait()) {
    if (rotateCanvasOverlay) {
      rotateCanvasOverlay.style.display = 'block';
      rotateCanvasOverlay.innerHTML = `
        <div style="color:#3cff7a; text-transform:uppercase; margin-bottom:6px; font-size:11px;">
          ROTATE DEVICE
        </div>
        <div>
          Rotate device to landscape<br>
          for the best experience
        </div>
      `;
      rotateCanvasOverlay.setAttribute('aria-hidden', 'false');
    }
  } else {
    if (rotateCanvasOverlay) {
      rotateCanvasOverlay.style.display = 'none';
      rotateCanvasOverlay.setAttribute('aria-hidden', 'true');
    }
  }
}

if (fullscreenBtn) {
  fullscreenBtn.addEventListener('click', () => {
    const isFs = document.body.classList.toggle('fullscreen-game');
    
    // Use innerHTML to preserve the line break and small text
    if (isFs) {
      fullscreenBtn.innerHTML = 'Exit Fullscreen<br><span style="font-size: 9px; opacity: 0.8;">(mobile)</span>';
    } else {
      fullscreenBtn.innerHTML = 'Fullscreen<br><span style="font-size: 9px; opacity: 0.8;">(mobile)</span>';
    }
    
    updateRotateOverlay();
  });
}

// Keep overlay in sync when user rotates or resizes
window.addEventListener('resize', updateRotateOverlay);
window.addEventListener('orientationchange', updateRotateOverlay);

// AUTO-EXIT SAFETY: If user rotates back to portrait, automatically exit fullscreen mode
window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    if (window.innerHeight > window.innerWidth) {
      // We are back in Portrait
      if (document.body.classList.contains('fullscreen-game')) {
        document.body.classList.remove('fullscreen-game');
        
        // Reset the button text
        const fsBtn = document.getElementById('fullscreen-toggle');
        if (fsBtn) {
          fsBtn.innerHTML = 'Fullscreen<br><span style="font-size: 9px; opacity: 0.8;">(mobile)</span>';
        }
        
        // Update the rotate overlay
        updateRotateOverlay();
      }
    }
  }, 200);
});

// Image variables used by the rest of the app
let characterImage, robotBoxImage, popUpAdImage, spamtonImage, asteriskImage;
let asteriskLoaded = false;
let imageLoaded = false; // used elsewhere to gate startGame()

// Helper that loads a single image and resolves with result (works with cached images)
function loadImage(src) {
  return new Promise(resolve => {
    const img = new Image();
    let settled = false;

    function finish(ok) {
      if (settled) return;
      settled = true;
      resolve({ img, ok });
    }

    img.onload = () => finish(true);
    img.onerror = () => finish(false);

    // Attach src after handlers are set
    img.src = src;

    // Some browsers won't call onload if the image was already in cache quickly;
    // detect that and resolve on next tick to let handlers attach.
    if (img.complete && img.naturalWidth) {
      setTimeout(() => finish(true), 0);
    }

    // Fallback safety: if nothing happens after a reasonable time, resolve as failed
    // (prevents hanging if network stalls). 6s is generous for local assets.
    setTimeout(() => {
      if (!settled) {
        console.warn('loadImage timeout for', src);
        finish(!!(img && img.naturalWidth));
      }
    }, 6000);
  });
}

// Load all assets in parallel and assign to the variables used elsewhere
(async function loadAllAssets() {
  try {
    const assets = [
  { name: 'characterImage', src: 'assets/string-flyer-spamton.png' },
  { name: 'robotBoxImage', src: 'assets/robot-box.png' },
  { name: 'popUpAdImage',  src: 'assets/pop-up-ad.png' },
  { name: 'spamtonImage',  src: 'assets/spamton.png' },
  { name: 'asteriskImage', src: 'assets/pixel-asterisk.png?cb=' + Date.now() }
];

    const promises = assets.map(a => loadImage(a.src).then(res => ({ name: a.name, ...res })));
    const results = await Promise.all(promises);

    // Assign images and track per-image success
    for (const r of results) {
      if (r.name === 'characterImage') characterImage = r.img;
      if (r.name === 'robotBoxImage') robotBoxImage = r.img;
      if (r.name === 'popUpAdImage')  popUpAdImage  = r.img;
      if (r.name === 'spamtonImage')  spamtonImage  = r.img;
      if (r.name === 'asteriskImage') {
        asteriskImage = r.img;
        asteriskLoaded = !!r.ok && !!asteriskImage.naturalWidth;
      }

      if (!r.ok) {
  console.warn(`asset ${r.name} failed to load:`, r.img.src);
} else if (DEBUG) {
  console.log(`asset ${r.name} loaded:`, r.img.src);
}
    }

    // Mark "imageLoaded" to allow game start attempt ‚Äî mirror previous behavior where onerror also set true.
    // This lets the game proceed with visual fallbacks even if some assets are missing.
    imageLoaded = true;

    if (DEBUG) console.log('All asset load attempts finished. imageLoaded:', imageLoaded, 'asteriskLoaded:', asteriskLoaded);
    checkReady();
  } catch (err) {
    console.error('Error while loading assets:', err);
    // Ensure we don't block startup forever
    imageLoaded = true;
    checkReady();
  }
})();

function checkReady() {
 if (DEBUG) console.log('checkReady called, imageLoaded:', imageLoaded);
if (imageLoaded) {
  if (typeof showWelcomeScreen === 'function') {
    if (DEBUG) console.log('Calling showWelcomeScreen');
    showWelcomeScreen();
  } else {
    console.error('showWelcomeScreen is not defined');
  }
}
}

/* Helper: position the uiOverlay and countdownOverlay to match the canvas location/size */
function positionOverlays(){
  const containerRect = document.querySelector('.game-container').getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  // compute position relative to container
  const left = canvasRect.left - containerRect.left;
  const top = canvasRect.top - containerRect.top;
  if (uiOverlay) {
    uiOverlay.style.left = (left) + 'px';
    uiOverlay.style.top = (top) + 'px';
    uiOverlay.style.width = canvasRect.width + 'px';
    uiOverlay.style.height = canvasRect.height + 'px';
    uiOverlay.style.pointerEvents = 'none'; // default; inner buttons override
  }

  if (countdownOverlay) {
    countdownOverlay.style.left = (left + canvasRect.width/2) + 'px';
    countdownOverlay.style.top = (top + canvasRect.height/2) + 'px';
  }
}

window.addEventListener('resize', () => {
  // recalc overlay positions when viewport changes
  setTimeout(positionOverlays, 40);
});
window.addEventListener('load', () => setTimeout(positionOverlays, 40));

function showWelcomeScreen() {
if (DEBUG) console.log('showWelcomeScreen called');
  try {
    const controlsDiv = document.getElementById('controls');
if (!controlsDiv) {
  console.warn('showWelcomeScreen: #controls not found (continuing anyway)');
} else {
  controlsDiv.innerHTML = '';
}

    if (uiOverlay) {
      // Set welcome message and Start button inside uiOverlay
      uiOverlay.setAttribute('aria-hidden', 'false');
      uiOverlay.innerHTML = `
        <div style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;">
          <div style="pointer-events:none;">
            <div style="font-family:'Press Start 2P',monospace;color:#0CAF0C;font-size:18px;text-shadow:0 0 6px rgba(12,175,12,0.25);">Welcome to Puppet Flyer!</div>
          </div>
          <button id="startBtn" class="pixel-btn" aria-label="Start Game">START GAME</button>
        </div>
      `;
      uiOverlay.style.pointerEvents = 'auto';

      // Attach start button handler (avoid relying on inline onclick)
      const startBtn = uiOverlay.querySelector('#startBtn');
      if (startBtn) {
        startBtn.addEventListener('click', () => {
          try { startGameWithCountdown(); } catch(e) { console.error('startBtn click error', e); }
        });
      }
    }

    positionOverlays();

    if (DEBUG) console.log('showWelcomeScreen completed');
  } catch (err) {
    console.error('showWelcomeScreen error:', err);
  }
}

/* ====
   Game state (unchanged)
   ==== */
let liveAsteriskRef = null;
let gameState = {
  started:false, over:false,
  player:{ x:100,y:200,width:80,height:80,velocity:0,pulling:false },
  obstacles:[], explosions:[], score:0,
  highScore: localStorage.getItem('puppetFlyerHighScore') || 0,
  gameSpeed:8, gravity:0.4, pullStrength:-7,
  obstacleTimer:0, asteriskTimer:0, asteriskSpawnStarted:false,
  spinningTimer:0, spawnInterval:80, startTime:0, elapsedTime:0, difficultyLevel:0,
  spamtonTimer:0, spamtonSpawnStarted:false
};

/* Settings used by physics boxes */
const ASTERISK_BASE = 50;
const ASTERISK_SIZE = Math.round(ASTERISK_BASE * 0.85);
const PHYSICS_SHRINK = 0.60;
const ENTERED_MARGIN = 8;
const ENTERED_GRACE_FRAMES = 6;

/* New: shrink factor for stationary obstacle collision boxes (tighten them) */
const OBSTACLE_PHYSICS_SHRINK = 0.78;

/* ====
   New: tight bounds per-image/per-size computation & cache
   ... (rest of code unchanged)
   ==== */
const tightBoundsCache = {};
const ALPHA_THRESHOLD = 10; // pixels with alpha > this count as opaque

function computeTightBoundsForImageAtSize(img, width, height){
  if (!img || !img.complete || img.naturalWidth === 0) return null;
  const key = `${img.src}|${width}x${height}`;
  if (tightBoundsCache[key]) return tightBoundsCache[key];

  try {
    const oc = document.createElement('canvas');
    oc.width = Math.max(1, Math.round(width));
    oc.height = Math.max(1, Math.round(height));
    const octx = oc.getContext('2d');
    octx.clearRect(0,0,oc.width,oc.height);
    octx.drawImage(img, 0, 0, oc.width, oc.height);
    const imgData = octx.getImageData(0,0,oc.width,oc.height).data;

    let minX = oc.width, minY = oc.height, maxX = -1, maxY = -1;
    for (let y = 0; y < oc.height; y++){
      for (let x = 0; x < oc.width; x++){
        const idx = (y * oc.width + x) * 4;
        const alpha = imgData[idx + 3];
        if (alpha > ALPHA_THRESHOLD){
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (maxX === -1) {
      const full = { x:0, y:0, width: oc.width, height: oc.height };
      tightBoundsCache[key] = full;
      return full;
    }

    const rect = {
      x: minX,
      y: minY,
      width: (maxX - minX + 1),
      height: (maxY - minY + 1)
    };
    tightBoundsCache[key] = rect;
    return rect;
  } catch (err){
    // getImageData can throw on cross-origin images ‚Äî fallback to full rect.
    tightBoundsCache[key] = { x:0, y:0, width: Math.round(width), height: Math.round(height) };
    return tightBoundsCache[key];
  }
}

function getAsteriskPhysicsBox(a){
  const padX = (a.width * (1 - PHYSICS_SHRINK)) / 2;
  const padY = (a.height * (1 - PHYSICS_SHRINK)) / 2;
  return { x: a.x + padX, y: a.y + padY, width: a.width - padX*2, height: a.height - padY*2 };
}

function getObstaclePhysicsBox(obs){
  if (obs.type === 'robotbox' || obs.type === 'popupad') {
    if (obs._tightBox) {
      return {
        x: Math.round(obs.x + obs._tightBox.x),
        y: Math.round(obs.y + obs._tightBox.y),
        width: Math.round(obs._tightBox.width),
        height: Math.round(obs._tightBox.height)
      };
    }
    let img = (obs.type === 'robotbox') ? robotBoxImage : popUpAdImage;
    const tb = computeTightBoundsForImageAtSize(img, Math.round(obs.width), Math.round(obs.height));
    if (tb) {
      obs._tightBox = tb;
      return {
        x: Math.round(obs.x + tb.x),
        y: Math.round(obs.y + tb.y),
        width: Math.round(tb.width),
        height: Math.round(tb.height)
      };
    }
    return { x: Math.round(obs.x), y: Math.round(obs.y), width: Math.round(obs.width), height: Math.round(obs.height) };
  }
  const shrink = OBSTACLE_PHYSICS_SHRINK;
  const padX = (obs.width * (1 - shrink)) / 2;
  const padY = (obs.height * (1 - shrink)) / 2;
  return { x: obs.x + padX, y: obs.y + padY, width: obs.width - padX*2, height: obs.height - padY*2 };
}

const HITBOX_STORAGE_KEY = 'pf_hitbox_config_v1';

const defaultHitboxConfig = {
  head:  { xOffset: 0.30, yOffset: 0.04, width: 0.36, height: 0.18, color: 'rgba(255,100,100,0.25)', stroke: 'rgba(255,100,100,0.95)' },
  torso: { xOffset: 0.26, yOffset: 0.30, width: 0.46, height: 0.32, color: 'rgba(100,200,255,0.25)', stroke: 'rgba(20,120,200,0.95)' },
  legs:  { xOffset: 0.36, yOffset: 0.66, width: 0.28, height: 0.30, color: 'rgba(150,255,150,0.25)', stroke: 'rgba(40,150,60,0.95)' }
};

let hitboxConfig = loadHitboxConfig();

function loadHitboxConfig(){
  try {
    const raw = localStorage.getItem(HITBOX_STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      return Object.assign({}, defaultHitboxConfig, parsed);
    }
  } catch(e){}
  return JSON.parse(JSON.stringify(defaultHitboxConfig));
}
function saveHitboxConfig(){
  try { localStorage.setItem(HITBOX_STORAGE_KEY, JSON.stringify(hitboxConfig)); } catch(e){}
}
function resetHitboxConfig(){
  hitboxConfig = JSON.parse(JSON.stringify(defaultHitboxConfig));
  saveHitboxConfig();
}

function getPlayerHitBoxes(){
  const p = gameState.player;
  const w = p.width;
  const h = p.height;

  const cfg = hitboxConfig;

  const torso = {
    x: Math.round(p.x + w * cfg.torso.xOffset),
    y: Math.round(p.y + h * cfg.torso.yOffset),
    width: Math.round(w * cfg.torso.width),
    height: Math.round(h * cfg.torso.height)
  };
  const legs = {
    x: Math.round(p.x + w * cfg.legs.xOffset),
    y: Math.round(p.y + h * cfg.legs.yOffset),
    width: Math.round(w * cfg.legs.width),
    height: Math.round(h * cfg.legs.height)
  };

  return [torso, legs];
}

function getPlayerBodyBox(){
  const p = gameState.player;
  const bodyX = Math.round(p.x + p.width * 0.32);
  const bodyY = Math.round(p.y + p.height * 0.18);
  const bodyW = Math.round(p.width * 0.36);
  const bodyH = Math.round(p.height * 0.64);
  return { x: bodyX, y: bodyY, width: bodyW, height: bodyH };
}

function drawPlayer(){
  const p = gameState.player;
  if (characterImage && characterImage.complete && characterImage.naturalWidth>0) ctx.drawImage(characterImage,p.x-8,p.y,p.width,p.height);
  else { ctx.fillStyle='#FF1493'; ctx.fillRect(p.x+15,p.y+10,40,35); }
}
function drawRope(){ const p=gameState.player; const ropeX=p.x+p.width/2; ctx.strokeStyle=p.pulling? '#0A8A0A':'#0CAF0C'; ctx.lineWidth=2; for(let i=-6;i<=6;i+=3){ ctx.beginPath(); ctx.moveTo(ropeX+i,0); ctx.lineTo(ropeX+i,p.y); ctx.stroke(); } ctx.fillStyle='#696969'; ctx.fillRect(ropeX-8,0,16,10); }

function generateRobotBoxObstacle(){
  const lower = 60;
  const upper = 95;
  const mid = (lower + upper) / 2;
  const p = Math.random();
  let size;
  if (p < 0.65) {
    size = lower + Math.random() * (mid - lower);
  } else {
    size = mid + Math.random() * (upper - mid);
  }
  size = Math.round(size);
  const y = 50 + Math.random() * Math.max(0, canvas.height - 50 - size);
  const obs = { x:canvas.width, y:y, width:size, height:size, type:'robotbox' };

  const tb = computeTightBoundsForImageAtSize(robotBoxImage, obs.width, obs.height);
  if (tb) obs._tightBox = tb;

  return obs;
}
function generatePopUpAdObstacle(){
  const isTop=Math.random()<0.5;
  const base=80;
  const r=Math.random();
  const t=Math.min(gameState.elapsedTime/60,1);
  const skew=Math.pow(r,1 - t*0.5);
  const lower = 0.75 * 1.2; // 0.9
  const upper = (0.92 * 1.2) * 1.2; // 1.3248
  const size = Math.round(base*(lower + skew*(upper - lower)));
  const y = isTop ? 0 : (canvas.height - size);
  const obs = { x:canvas.width, y:y, width:size, height:size, type:'popupad' };

  const tb = computeTightBoundsForImageAtSize(popUpAdImage, obs.width, obs.height);
  if (tb) obs._tightBox = tb;

  return obs;
}

function generateAsteriskObstacle(){
  const asteriskSize = ASTERISK_SIZE;
  const marginOut = 10;

  const r = Math.random();
  let spawnEdge;
  if (r < 0.60) {
    spawnEdge = 'right';
  } else if (r < 0.85) {
    spawnEdge = Math.random() < 0.5 ? 'top' : 'bottom';
  } else {
    spawnEdge = 'left';
  }

  let x, y;
  if (spawnEdge === 'left') {
    x = -asteriskSize - marginOut;
    y = Math.random() * (canvas.height - asteriskSize);
  } else if (spawnEdge === 'right') {
    x = canvas.width + asteriskSize + marginOut;
    y = Math.random() * (canvas.height - asteriskSize);
  } else if (spawnEdge === 'top') {
    x = Math.random() * (canvas.width - asteriskSize);
    y = -asteriskSize - marginOut;
  } else {
    x = Math.random() * (canvas.width - asteriskSize);
    y = canvas.height + asteriskSize + marginOut;
  }

  const t = Math.max(gameState.elapsedTime - 16, 0);
  const minSpeedStart = 1.5, maxSpeedStart = 3.0, minSpeedEnd = 4.0, maxSpeedEnd = 7.0;
  const rampDuration = 40;
  const progress = Math.min(t / rampDuration, 1);
  let minSpeed = minSpeedStart + (minSpeedEnd - minSpeedStart)*progress;
  let maxSpeed = maxSpeedStart + (maxSpeedEnd - maxSpeedStart)*progress;
  let speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

  const deg2rad = deg => deg * Math.PI / 180;

  let angle;
  if (spawnEdge === 'right') {
    angle = Math.PI + (Math.random()*2 - 1) * deg2rad(15);
  } else if (spawnEdge === 'left') {
    angle = 0 + (Math.random()*2 - 1) * deg2rad(15);
  } else if (spawnEdge === 'top') {
    angle = Math.PI/2 + (Math.random()*2 - 1) * deg2rad(30);
  } else {
    angle = -Math.PI/2 + (Math.random()*2 - 1) * deg2rad(30);
  }

  if ((spawnEdge === 'top' || spawnEdge === 'bottom') && x > canvas.width / 2) {
    angle = Math.PI + (Math.random()*2 - 1) * deg2rad(20);
    const required = Math.max(gameState.gameSpeed * 1.2, maxSpeed);
    if (speed < required) speed = required;
    maxSpeed = Math.max(maxSpeed, required);
  }

  if (spawnEdge === 'right') {
    const required = Math.max(gameState.gameSpeed * 1.2, maxSpeed);
    if (speed < required) {
      speed = required;
      maxSpeed = Math.max(maxSpeed, required);
    }
  }

  let vx = Math.cos(angle) * speed;
  let vy = Math.sin(angle) * speed;

  if (spawnEdge === 'right' && vx > 0) vx = -Math.abs(vx);
  if (spawnEdge === 'left'  && vx < 0) vx = Math.abs(vx);
  if (spawnEdge === 'top'   && vy < 0) vy = Math.abs(vy);
  if (spawnEdge === 'bottom'&& vy > 0) vy = -Math.abs(vy);

  const typicalSpeed = (minSpeed + maxSpeed) / 2;
  const minHorizontal = Math.max(0.28 * typicalSpeed, 0.4);
  const minVertical = Math.max(0.12 * typicalSpeed, 0.12);

  if (spawnEdge === 'left' || spawnEdge === 'right') {
    if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
  } else {
    if (Math.abs(vy) < minVertical) vy = (vy < 0 ? -1 : 1) * minVertical;
  }

  const PAD = 6;
  let timeToVisible = null;

  if (spawnEdge === 'right' && vx !== 0) {
    timeToVisible = (canvas.width - x) / vx;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
      const predictedY = y + vy * timeToVisible;
      const minY = PAD;
      const maxY = canvas.height - asteriskSize - PAD;
      if (predictedY < minY || predictedY > maxY) {
        const targetY = Math.max(minY, Math.min(maxY, predictedY < minY ? minY : maxY));
        vy = (targetY - y) / timeToVisible;
      }
    }
  } else if (spawnEdge === 'left' && vx !== 0) {
    timeToVisible = (0 - (x + asteriskSize)) / vx;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
      const predictedY = y + vy * timeToVisible;
      const minY = PAD;
      const maxY = canvas.height - asteriskSize - PAD;
      if (predictedY < minY || predictedY > maxY) {
        const targetY = Math.max(minY, Math.min(maxY, predictedY < minY ? minY : maxY));
        vy = (targetY - y) / timeToVisible;
      }
    }
  } else if (spawnEdge === 'top' && vy !== 0) {
    timeToVisible = (0 - (y + asteriskSize)) / vy;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
      const predictedX = x + vx * timeToVisible;
      const minX = PAD;
      const maxX = canvas.width - asteriskSize - PAD;
      if (predictedX < minX || predictedX > maxX) {
        const targetX = Math.max(minX, Math.min(maxX, predictedX < minX ? minX : maxX));
        vx = (targetX - x) / timeToVisible;
        if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
      }
    }
  } else if (spawnEdge === 'bottom' && vy !== 0) {
    timeToVisible = (canvas.height - y) / vy;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
      const predictedX = x + vx * timeToVisible;
      const minX = PAD;
      const maxX = canvas.width - asteriskSize - PAD;
      if (predictedX < minX || predictedX > maxX) {
        const targetX = Math.max(minX, Math.min(maxX, predictedX < minX ? minX : maxX));
        vx = (targetX - x) / timeToVisible;
        if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
      }
    }
  }

  let intersectionTime = null;
  if (spawnEdge === 'right' && vx !== 0) {
    const targetX = canvas.width - asteriskSize - 1;
    intersectionTime = (targetX - x) / vx;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
      x = x + vx * intersectionTime;
      y = y + vy * intersectionTime;
    } else {
      x = canvas.width - asteriskSize - 1;
    }
  } else if (spawnEdge === 'left' && vx !== 0) {
    const targetX = 1;
    intersectionTime = (targetX - x) / vx;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
      x = x + vx * intersectionTime;
      y = y + vy * intersectionTime;
    } else {
      x = 1;
    }
  } else if (spawnEdge === 'top' && vy !== 0) {
    const targetY = 1;
    intersectionTime = (targetY - y) / vy;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
      x = x + vx * intersectionTime;
      y = y + vy * intersectionTime;
    } else {
      y = 1;
    }
  } else if (spawnEdge === 'bottom' && vy !== 0) {
    const targetY = canvas.height - asteriskSize - 1;
    intersectionTime = (targetY - y) / vy;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
      x = x + vx * intersectionTime;
      y = y + vy * intersectionTime;
    } else {
      y = canvas.height - asteriskSize - 1;
    }
  }

  x = Math.max(0, Math.min(canvas.width - asteriskSize, x));
  y = Math.max(0, Math.min(canvas.height - asteriskSize, y));

  const preAdvanceSteps = 1;
  x += vx * preAdvanceSteps;
  y += vy * preAdvanceSteps;

  const a = {
    x, y, width: asteriskSize, height: asteriskSize,
    vx, vy,
    type: 'asterisk', rotation: Math.random()*Math.PI*2,
    entered:false, age:1, _remove:false
  };

  return a;
}

function generateSpamtonObstacle(){
  const size = Math.round(64 * 0.67);
  const marginOut = 12;
  const edges = ['top','right','bottom'];
  const spawnEdge = edges[Math.floor(Math.random()*edges.length)];

  let x, y;
  if (spawnEdge === 'right') {
    x = canvas.width + size + marginOut;
    y = Math.random() * (canvas.height - size);
  } else if (spawnEdge === 'top') {
    const minX = Math.floor(canvas.width * 2 / 3);
    const maxX = canvas.width - size - 1;
    x = minX + Math.random() * Math.max(0, maxX - minX);
    y = -size - marginOut;
  } else {
    const minX = Math.floor(canvas.width * 2 / 3);
    const maxX = canvas.width - size - 1;
    x = minX + Math.random() * Math.max(0, maxX - minX);
    y = canvas.height + size + marginOut;
  }

  const deg2rad = deg => deg * Math.PI / 180;
  let angleDeg;
  if (spawnEdge === 'top') {
    angleDeg = 105 + Math.random() * (165 - 105);
  } else if (spawnEdge === 'right') {
    angleDeg = 165 + Math.random() * (195 - 165);
  } else {
    angleDeg = 195 + Math.random() * (255 - 195);
  }
  const angle = deg2rad(angleDeg);

  let minSpeed = Math.max(gameState.gameSpeed * 1.08, 3.5);
  let maxSpeed = Math.max(gameState.gameSpeed * 1.25, 5.5);

  minSpeed *= 1.10;
  maxSpeed *= 1.10;

  const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

  let vx = Math.cos(angle) * speed;
  let vy = Math.sin(angle) * speed;

  if (vx > -Math.abs(gameState.gameSpeed * 0.95)) {
    const chosen = minSpeed + Math.random() * (Math.max(maxSpeed - minSpeed, 0.5));
    vx = -Math.abs(chosen);
    vy = (Math.random() - 0.5) * (Math.abs(chosen) * 0.35);
  }

  if (spawnEdge === 'right') {
    x = canvas.width - size - 1;
  } else if (spawnEdge === 'top') {
    y = 1;
  } else if (spawnEdge === 'bottom') {
    y = canvas.height - size - 1;
  }

  x += vx * 1;
  y += vy * 1;

  const rotation = Math.random()*Math.PI*2;
  let rotationSpeed = ((Math.random()*0.06 - 0.03) * (0.6 + Math.random()*1.0)) * 2;
  rotationSpeed *= 1.15;

  const s = {
    x, y, width: size, height: size,
    vx, vy,
    type: 'spamton',
    rotation, rotationSpeed,
    entered:false, age:1, _remove:false
  };

  return s;
}

function drawObstacles(){
  gameState.obstacles.forEach(obs=>{
    if (obs.type==='robotbox'){
      if (robotBoxImage && robotBoxImage.complete && robotBoxImage.naturalWidth>0) ctx.drawImage(robotBoxImage, obs.x, obs.y, obs.width, obs.height);
      else { ctx.fillStyle='#FF6B6B'; ctx.fillRect(obs.x,obs.y,obs.width,obs.height); }
    } else if (obs.type==='popupad'){
      if (popUpAdImage && popUpAdImage.complete && popUpAdImage.naturalWidth>0) ctx.drawImage(popUpAdImage, obs.x, obs.y, obs.width, obs.height);
      else { ctx.fillStyle='#9B59B6'; ctx.fillRect(obs.x,obs.y,obs.width,obs.height); }
    } else if (obs.type==='asterisk' || obs.type==='spamton'){
      ctx.save(); ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2); ctx.rotate(obs.rotation);
      if (obs.type==='asterisk') {
        if (asteriskLoaded && asteriskImage.complete && asteriskImage.naturalWidth>0) ctx.drawImage(asteriskImage, -obs.width/2, -obs.height/2, obs.width, obs.height);
        else { ctx.strokeStyle='#FFF'; ctx.lineWidth=4; const s=obs.width/2; ctx.beginPath(); ctx.moveTo(-s,0); ctx.lineTo(s,0); ctx.moveTo(0,-s); ctx.lineTo(0,s); ctx.stroke(); }
        obs.rotation += 0.05;
      } else { // spamton
        if (spamtonImage && spamtonImage.complete && spamtonImage.naturalWidth>0) ctx.drawImage(spamtonImage, -obs.width/2, -obs.height/2, obs.width, obs.height);
        else { ctx.fillStyle='#FFF'; ctx.fillRect(-obs.width/2, -obs.height/2, obs.width, obs.height); }
        obs.rotation += obs.rotationSpeed || 0.03;
      }
      ctx.restore();
    }
  });
}

function createExplosion(x,y){ const particles=[]; for(let i=0;i<12;i++){ const angle=(Math.PI*2*i)/12; particles.push({x,y,vx:Math.cos(angle)*(2+Math.random()*3),vy:Math.sin(angle)*(2+Math.random()*3),life:20+Math.random()*10,maxLife:30}); } gameState.explosions.push({x,y,particles,life:30}); }
function drawExplosions(){ gameState.explosions = gameState.explosions.filter(ex=>{ ex.life--; ex.particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.life--; const alpha = p.life / p.maxLife; const size = 4 * (p.life / p.maxLife); ctx.fillStyle = `rgba(255,215,0,${alpha})`; ctx.fillRect(p.x-size/2,p.y-size/2,size,size); }); return ex.life>0; }); }

function rectsOverlap(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}

function checkCollision(){
  const body = getPlayerBodyBox(); // for boundary checks only
  const hitBoxes = getPlayerHitBoxes(); // now only torso and legs

  if (body.y <= 0 || body.y + body.height >= canvas.height) {
    createExplosion(body.x + body.width/2, body.y + body.height/2);
    return true;
  }

  for (let i=0;i<gameState.obstacles.length;i++){
    const obs = gameState.obstacles[i];

    if (obs.type === 'asterisk' || obs.type === 'spamton') {
      const pb = getAsteriskPhysicsBox(obs);

      let collided = false;
      let collidedHitBox = null;
      for (let hb of hitBoxes) {
        if (rectsOverlap(hb, pb)) { collided = true; collidedHitBox = hb; break; }
      }

      if (collided) {
        createExplosion(collidedHitBox.x + collidedHitBox.width/2, collidedHitBox.y + collidedHitBox.height/2);
        gameState.obstacles.splice(i,1);
        return true;
      }

    } else {
      const obstBox = getObstaclePhysicsBox(obs);
      let collided = false;
      let collidedHitBox = null;
      for (let hb of hitBoxes) {
        if (rectsOverlap(hb, obstBox)) { collided = true; collidedHitBox = hb; break; }
      }
      if (collided) {
        createExplosion(collidedHitBox.x + collidedHitBox.width/2, collidedHitBox.y + collidedHitBox.height/2);
        return true;
      }
    }
  }
  return false;
}

function gameLoop(){
  if (gameState.over) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);

  if (gameState.player.pulling) gameState.player.velocity = gameState.pullStrength;
  else gameState.player.velocity += gameState.gravity;
  gameState.player.y += gameState.player.velocity;

  drawRope();
  drawPlayer();

  gameState.elapsedTime = (Date.now() - gameState.startTime)/1000;
  gameState.score = gameState.elapsedTime * 10;

  gameState.obstacleTimer++;
  const spawnInterval = 60 + Math.random()*40;
  if (gameState.obstacleTimer > spawnInterval) {
    if (gameState.elapsedTime >= 12 && Math.random() < 0.15) {
      const rb = generateRobotBoxObstacle();
      const pu = generatePopUpAdObstacle();
      const planeX = canvas.width;
      rb.x = planeX;
      pu.x = planeX;
      rb.width = rb.height = 60;
      pu.width = pu.height = Math.round(80 * 0.9);

      if (!(rb.y + rb.height <= pu.y || pu.y + pu.height <= rb.y)) {
        let newY = pu.y + pu.height + 6;
        if (newY + rb.height <= canvas.height) {
          rb.y = newY;
        } else {
          newY = pu.y - rb.height - 6;
          rb.y = Math.max(0, newY);
        }
        rb.y = Math.max(0, Math.min(canvas.height - rb.height, rb.y));
      }

      const tbRb = computeTightBoundsForImageAtSize(robotBoxImage, rb.width, rb.height);
      if (tbRb) rb._tightBox = tbRb;
      const tbPu = computeTightBoundsForImageAtSize(popUpAdImage, pu.width, pu.height);
      if (tbPu) pu._tightBox = tbPu;

      gameState.obstacles.push(rb);
      gameState.obstacles.push(pu);
    } else {
      if (Math.random()<0.5) gameState.obstacles.push(generateRobotBoxObstacle());
      else gameState.obstacles.push(generatePopUpAdObstacle());
    }
    gameState.obstacleTimer = 0;
  }

  if (gameState.elapsedTime >= 16) {
    if (!gameState.asteriskSpawnStarted) {
      let a = generateAsteriskObstacle();
      const pb0 = getAsteriskPhysicsBox(a);
      const fullyInsideAtSpawn = (pb0.x >= ENTERED_MARGIN && pb0.x + pb0.width <= canvas.width - ENTERED_MARGIN && pb0.y >= ENTERED_MARGIN && pb0.y + pb0.height <= canvas.height - ENTERED_MARGIN);
      if (fullyInsideAtSpawn) a.entered = true;
      gameState.obstacles.push(a);
      liveAsteriskRef = a;
      gameState.asteriskSpawnStarted = true;
      gameState.asteriskTimer = 0;
    }

    gameState.asteriskTimer++;
    const timeSinceA = Math.max(gameState.elapsedTime - 16, 0);
    const ramp=60, startI=160, endI=40, prog = Math.min(timeSinceA / ramp, 1);
    const aInterval = Math.round(startI + (endI - startI) * prog);
    if (gameState.asteriskTimer >= aInterval) {
      const a = generateAsteriskObstacle();
      gameState.obstacles.push(a);
      liveAsteriskRef = a;
      gameState.asteriskTimer = 0;
    }
  }

  if (gameState.elapsedTime >= 24) {
    if (!gameState.spamtonSpawnStarted) {
      const s = generateSpamtonObstacle();
      gameState.obstacles.push(s);
      gameState.spamtonSpawnStarted = true;
      gameState.spamtonTimer = 0;
    }
    gameState.spamtonTimer++;
    const minI = 240; // doubled interval (less frequent)
    const maxI = 720;
    const elapsedFactor = Math.min(gameState.elapsedTime / 120, 1);
    const chosenInterval = Math.round(minI + (maxI - minI) * (1 - elapsedFactor) * Math.random());
    if (gameState.spamtonTimer >= chosenInterval) {
      const s = generateSpamtonObstacle();
      gameState.obstacles.push(s);
      gameState.spamtonTimer = 0;
    }
  }

  gameState.obstacles = gameState.obstacles.filter(obs=>{
    if (obs._remove) return false;

    if (obs.type==='asterisk' || obs.type==='spamton'){
      obs.x += obs.vx; obs.y += obs.vy;
      obs.age = (obs.age || 0) + 1;

      const pb = getAsteriskPhysicsBox(obs);
      const fullyInside = (pb.x >= ENTERED_MARGIN && pb.x + pb.width <= canvas.width - ENTERED_MARGIN && pb.y >= ENTERED_MARGIN && pb.y + pb.height <= canvas.height - ENTERED_MARGIN);
      if (!obs.entered && fullyInside && obs.age > ENTERED_GRACE_FRAMES) {
        obs.entered = true;
      }

      const hitEdge = obs.entered && (pb.x <= 0 || pb.x + pb.width >= canvas.width || pb.y <= 0 || pb.y + pb.height >= canvas.height);
      if (hitEdge) {
        if (liveAsteriskRef === obs) liveAsteriskRef = null;
        createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
        return false;
      }

      if (obs.x + obs.width < -150 || obs.x > canvas.width + 150 || obs.y + obs.height < -150 || obs.y > canvas.height + 150) {
        if (liveAsteriskRef === obs) liveAsteriskRef = null;
        return false;
      }

      if (obs.entered) {
        for (let other of gameState.obstacles) {
          if (other === obs) continue;
          if (other._remove) continue;

          if (other.type !== 'asterisk' && other.type !== 'spamton') {
            const otherBox = getObstaclePhysicsBox(other);
            if (pb.x < otherBox.x + otherBox.width && pb.x + pb.width > otherBox.x && pb.y < otherBox.y + otherBox.height && pb.y + pb.height > otherBox.y) {
              if (liveAsteriskRef === obs) liveAsteriskRef = null;
              createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
              return false;
            }
            continue;
          }

          if (other.type === 'asterisk' || other.type === 'spamton') {
            const pbOther = getAsteriskPhysicsBox(other);
            if (rectsOverlap(pb, pbOther)) {
              other._remove = true;
              createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
              createExplosion(other.x + other.width/2, other.y + other.height/2);
              if (liveAsteriskRef === obs) liveAsteriskRef = null;
              if (liveAsteriskRef === other) liveAsteriskRef = null;
              return false;
            }
          }
        }
      }

      return true;
    } else {
      obs.x -= gameState.gameSpeed;
      return obs.x + obs.width > 0;
    }
  });

  drawObstacles();
  drawExplosions();

  if (checkCollision()) { endGame(); return; }

  ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px monospace';
  ctx.fillText(`Score: ${Math.floor(gameState.score)}`, 10, 30);
  ctx.fillText(`Time: ${Math.floor(gameState.elapsedTime)}s`, 10, 55);
  ctx.fillText(`Level: ${gameState.difficultyLevel + 1}`, 10, 80);

  requestAnimationFrame(gameLoop);
}

function startGame(){
  if (!imageLoaded) { alert('Please wait for images to load'); return; }
  gameState = {
    started:true, over:false,
    player:{ x:100,y:200,width:80,height:80,velocity:0,pulling:false },
    obstacles:[], explosions:[], score:0,
    highScore: localStorage.getItem('puppetFlyerHighScore') || 0,
    gameSpeed:8, gravity:0.4, pullStrength:-7,
    obstacleTimer:0, asteriskTimer:0, asteriskSpawnStarted:false,
    spinningTimer:0, spawnInterval:80, startTime:Date.now(), elapsedTime:0, difficultyLevel:0,
    spamtonTimer:0, spamtonSpawnStarted:false
  };
  liveAsteriskRef = null;
  // clear UI overlay when game starts
  if (uiOverlay) {
    uiOverlay.innerHTML = '';
    uiOverlay.style.pointerEvents = 'none';
  }
  if (controlsDiv) controlsDiv.innerHTML = '';
  gameLoop();
}

async function endGame(){
  gameState.over = true;
  const finalScore = Math.floor(gameState.score);
  if (finalScore > gameState.highScore) {
    gameState.highScore = finalScore;
    localStorage.setItem('puppetFlyerHighScore', finalScore);
  }

  // Show GAME OVER & Score inside the black game area (uiOverlay) immediately
  if (uiOverlay) {
    uiOverlay.setAttribute('aria-hidden', 'false');
    uiOverlay.innerHTML = `
      <div style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <div class="game-over">GAME OVER</div>
        <div class="high-score">Score: ${finalScore}</div>
        <button class="pixel-btn" id="playAgainBtn">PLAY AGAIN</button>
      </div>
    `;
    uiOverlay.style.pointerEvents = 'auto';

    const playAgainBtn = uiOverlay.querySelector('#playAgainBtn');
    if (playAgainBtn) playAgainBtn.addEventListener('click', () => { try { startGameWithCountdown(); } catch(e) { console.error(e); }});
    positionOverlays();
  }

  // Submit the score asynchronously, but only if the function exists
if (window.submitScoreToServer && typeof window.submitScoreToServer === 'function') {
  window.submitScoreToServer(finalScore)
    .then(() => {
      // remove console.log or keep only on DEBUG
if (DEBUG) console.log("Score submitted:", finalScore);

      // Refresh player stats display
      if (window.loadPlayerStats && typeof window.loadPlayerStats === 'function') {
        window.loadPlayerStats();
      }

      // Refresh global leaderboard display
      if (window.loadLeaderboard && typeof window.loadLeaderboard === 'function') {
        // Find the currently active leaderboard tab button
        const activeBtn = document.querySelector('#btn-weekly.active, #btn-monthly.active, #btn-alltime.active');
        const period = activeBtn ? activeBtn.id.replace('btn-', '') : 'weekly'; // default to weekly if none active
        window.loadLeaderboard(period);
      }
    })
    .catch(err => {
      console.error("Score submission failed:", err);
    });
}

}

/* ====
   Input handlers (unchanged)
   ==== */
window.addEventListener('keydown', e => { if (e.code==='Space' && gameState.started && !gameState.over) { e.preventDefault(); gameState.player.pulling = true; }});
window.addEventListener('keyup', e => { if (e.code==='Space') { e.preventDefault(); gameState.player.pulling = false; }});
if (canvas) {
  canvas.addEventListener('mousedown', e => { if (gameState.started && !gameState.over) { e.preventDefault(); gameState.player.pulling = true; }});
  canvas.addEventListener('mouseup', e => { e.preventDefault(); gameState.player.pulling = false; });
  canvas.addEventListener('touchstart', e => { if (gameState.started && !gameState.over) { e.preventDefault(); e.stopPropagation(); gameState.player.pulling = true; } }, { passive:false });
  canvas.addEventListener('touchend', e => { e.preventDefault(); e.stopPropagation(); gameState.player.pulling = false; }, { passive:false });
}

/* Countdown helper (minimal, does not alter game code) */
function startGameWithCountdown(){
  const overlay = document.getElementById('countdownOverlay');
  const numEl = document.getElementById('countdownNumber');
  if (!overlay || !numEl) {
    // fallback: immediately hide UI overlay and start
    if (uiOverlay) {
      uiOverlay.innerHTML = '';
      uiOverlay.style.pointerEvents = 'none';
    }
    startGame();
    return;
  }

  // IMMEDIATE: hide any UI text/buttons so only the countdown appears
  if (uiOverlay) {
    uiOverlay.setAttribute('aria-hidden', 'true');
    uiOverlay.innerHTML = '';
    uiOverlay.style.pointerEvents = 'none';
  }

  overlay.style.display = 'flex';
  overlay.setAttribute('aria-hidden', 'false');

  const values = ['3','2','1'];
  let i = 0;

  function showNext(){
    if (i < values.length) {
      numEl.textContent = values[i];
      numEl.style.color = '#0CAF0C';
      numEl.classList.remove('show');
      // force reflow to restart transition
      void numEl.offsetWidth;
      numEl.classList.add('show');
      i++;
      setTimeout(() => {
        numEl.classList.remove('show');
        setTimeout(showNext, 220);
      }, 720);
    } else {
      // GO!
      numEl.textContent = 'GO!';
      numEl.style.color = '#3AFF6B';
      numEl.classList.add('show');
      setTimeout(() => {
        numEl.classList.remove('show');
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
        // call original start
        startGame();
      }, 420);
    }
  }
  positionOverlays();
  showNext();
}

// ========== RULES MODAL ==========
const rulesButton = document.getElementById('rules-button');
const rulesModal = document.getElementById('rules-modal');
const closeRules = document.getElementById('close-rules');

rulesButton.addEventListener('click', () => {
  rulesModal.classList.remove('hidden');
});

closeRules.addEventListener('click', () => {
  rulesModal.classList.add('hidden');
});

rulesModal.addEventListener('click', (e) => {
  if (e.target === rulesModal) {
    rulesModal.classList.add('hidden');
  }
});

// Expose start functions and gameState to global scope so inline attributes and other scripts keep working
window.startGame = startGame;
window.startGameWithCountdown = startGameWithCountdown;
window.gameState = gameState;

// If an image already loaded prior to DOMContentLoaded, call checkReady now
if (imageLoaded) {
  setTimeout(checkReady, 0);
}

});
</script>

<script src="js/script.bundle.js"></script>
<script src="js/index.bundle.js"></script>

</body>
</html>
